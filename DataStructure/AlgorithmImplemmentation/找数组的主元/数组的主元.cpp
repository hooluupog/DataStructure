/***************************************************************************************************************
**   数组的主元
**   一个数组中出现次数超过数组大小的一半的元素成为数组的主元，比如:int a[]={1,2,3,1,1,1,1,1,6};数组大小为9，其中1这
**   个元素出现的次数为6，超过了9的一半，所以它是这个数组a的主元一个数组可能没有主元，比如 int b[]={1,2,3,4}就没有主
**   元。
**   输入：n 表中元素数目
**         A 存储元素的线性表
**   输出：A中的主元或者报告没有主元
***************************************************************************************************************/

#include <iostream>
#include <stdio.h>
using namespace std;

int principal(int a[],int n)
{
    int y;
    if(n == 0)   return -1;  //未找到主元
    if(n == 1)   return a[0]; //数组中的元素就是唯一的主元，直接返回结果
    int s[n/2];  //n数组中的元素两两配对，若对中元素则放入其中一个到s中
    for (int i=0; i<n/2; ++i) s[i] = 0; //初始化s数组为0
    int i = 0,j=0;
    while(i<n-1)
    {
        if(a[i] == a[i+1])
            s[j++] = a[i];
            i += 2;
    }
    y = principal(s,j);//递归调用该算法寻找s中的主元,找的主元存入y中作为a的主元候选者
    int num = 0; // 统计某个元素在a中出现的次数
    if(n%2 != 0)  //n为奇数
    {
       int x = a[n-1]; //如果n为奇数，x存放配对之后剩余的那个元素作为a的主元候选者
       if(y != -1)
       {
           for(int i = 0; i<n;++i)
            if(y == a[i])
            num ++;
           if(num > n/2) //y出现次数超过容量的一半，找到主元
           return y;
       }
       num = 0;
       for(int i = 0; i<n;++i)
        if(x == a[i])
            num ++;
        if(num > n/2) //x出现次数超过容量的一半，找到主元
         return x;
       return -1;
    }
    else  //n为偶数
    {
        if(y != -1)
        {
            for(int i = 0; i<n;++i)
             if(y == a[i])
                num ++;
           if(num > n/2) //y出现次数超过容量的一半，找到主元
           return y;
        }
        return -1;
    }
}

int main()
{
    int a[9] = {1,2,3,1,1,1,1,1,6};
    int result = principal(a,9);
    if(result == -1)
        printf("数组中不存在主元\n");
    else
        printf("数组的主元为： %d\n",result);
    return 0;
}

/***************************************************************************************************************
**  算法思想：
**  1. 如果n = 0，则没有主元，算法结束；
**      如果n = 1，则唯一的元素就是主元，直接将其返回，算法结束；
**  2. 把n个元素任意地两两配对，得到 [n/2]对；
**     如果n是奇数，则把最后配对剩下的那个元素x单独作为主元候选元素；
**  3. 表S初始化为空；
**  4. 对于[n/2]对元素，分别比较每对中的两个元素；
**     如果某对中的两个元素相同，则取出此对中其中任意一个元素加入表S；
**  5. 递归调用本算法，在S中找出主元；
**     如果S的主元存在的话，设其为y，将其作为主元候选元素；
**  6. 对于前面得到的主元候选元素x,y，分别用他们(如果他们存在的话)来测试数组中的每一元素；
**     如果和他们相同的元素数目超过n/2，则找到了A的主元； 否则A就没有主元。
**
**  算法的时间复杂度：
**
**  设对于n个元素算法需要进行T(n)次比较。
**  算法的第4行需要进行n/2次比较；
**  第5行对S递归调用此算法，S的规模最多是n/2，所以需要进行T(n/2)次比较；
**  第6行最多需要进行2n次比较。
**  所以有
**  T(n) = n/2 + T(n/2) + 2n
**  假设T(n) = c*n，这里c是一个常数，则
**  cn = n/2 + cn/2 + 2n
**  即 c = 5
**  所以T(n) = 5n
**  因此这是一个线性算法。
**
**  算法的正确性证明：
**
**  1.n为偶数
**
**  如果原来的序列中存在主元，因为主元的数目要大于n/2，则根据鸽笼原理，所
**  有元素两两配对后，必然有某对元素完全相同，且等于主元。这是主元存在的必
**  要条件，因此主元只可能出现在两两配对后，完全相同的某对元素中。假设从这
**  些相同的每一对中分别取出一个元素，组成集合S，我们可以证明，如果原来序
**  列的主元存在，则他一定也是S中的主元。
**
**  我们不妨假设n=2k，两两配对的时候，A[i]和A[i+1]互相配对, i = 1,2,...,k。
**  不失一般性，可以假设A[i]=A[i+1]=x是A的主元。如果还存在另外一对相等
**  的元素A[j]=A[j+1]，且A[j]<>x，即A[j]不是主元。那么除去
**  A[i],A[i+1],A[j],A[j+1]还剩下n-4个元素，其中有超过n/2 - 2 = (n-4)/2个x。
**  换句话说，x还是剩下的元素中的主元。还是根据鸽笼原理，除去
**  A[i],A[i+1],A[j],A[j+1]外的配对中，一定还有某对A[k]=A[k+1]=x。因此，在
**  两两相等的对中，只要存在某个非主元对(A[j],A[j+1])，一定存在另一个主元
**  对(A[k],A[k+1])和他对应。而最终主元对会多出一对(A[i],A[i+1])，所以
**  表A中的主元x也是表S中的主元。
**
**  因此，我们只需要在表S中寻找主元，将其作为主元候选即可。这就是算法第4，
**  5行所作的工作。
**
**  如果表A有主元，则他一定也是表S的主元；但表S的主元则不一定是表A的主元。所以
**  在算法的第6行验证所得到的候选主元，最终确定他是否是表A的主元。
**
**  2. n为奇数
**
**  这和n为偶数差不多，但唯一的区别是，配对剩下的那个元素有可能是主元的候
**  选元素。例如n=2k+1，只有所有奇数位置的元素是主元，配对的时候A[i]和
**  A[i+1]配对，这样没有任意一对两元素相同，但主元是最后剩下的没能配对的那
**  个元素。为了处理这种情况，我们必须单独验证这个没有被配对的元素。其他的
**  过程和n为偶数的情况完全一致。
**
**  由此可见，这个线性算法可以正确地判断主元是否存在，并在主元存在时求出主元。
***************************************************************************************************************/
